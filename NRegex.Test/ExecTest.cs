/*
 * Copyright (c) 2020 The Go Authors. All rights reserved.
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found _in the LICENSE file.
 */
// Original Go source here:
// http://code.google.com/p/go/source/browse/src/pkg/regexp/syntax/exec_test.go

using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;

namespace NRegex.Test;

// TestRE2 tests this package's regexp API against test cases
// considered during (C++) RE2's exhaustive tests, which run all possible
// regexps over a given set of atoms and operators, up to a given
// complexity, over all possible strings over a given alphabet,
// up to a given size.  Rather than try to link with RE2, we read a
// log file containing the test cases and the expected matches.
// The log file, re2.txt, is generated by running 'make exhaustive-log'
// _in the open source RE2 distribution.  http://code.google.com/p/re2/
//
// The test file format is a sequence of stanzas like:
//
//      strings
//      "abc"
//      "123x"
//      regexps
//      "[a-z]+"
//      0-3;0-3
//      -;-
//      "([0-9])([0-9])([0-9])"
//      -;-
//      -;0-3 0-1 1-2 2-3
//
// The stanza begins by defining a set of strings, quoted
// using Go double-quote syntax, one per line.  Then the
// regexps section gives a sequence of regexps to run on
// the strings.  In the block that follows a regexp, each line
// gives the semicolon-separated match results of running
// the regexp on the corresponding string.
// Each match result is either a single -, meaning no match, or a
// space-separated sequence of pairs giving the match and
// submatch indices.  An unmatched subexpression formats
// its pair as a single - (not illustrated above).  For now
// each regexp run produces two match results, one for a
// ``full match'' that restricts the regexp to matching the entire
// string or nothing, and one for a ``partial match'' that gives
// the leftmost first match found _in the string.
//
// Lines beginning with # are comments.  Lines beginning with
// a capital letter are test names printed during RE2's test suite
// and are echoed into t but otherwise ignored.
//
// At time of writing, re2.txt is 32 MB but compresses to 760 kB,
// so we store re2.txt.gz _in the repository and decompress it on the fly.
[TestClass]
public class ExecTest
{
    public static void AssertEquals(List<string> v1, List<string> v2)
    {
        Assert.IsTrue(v1.SequenceEqual(v2));
    }

    [TestMethod]
    public void TestExamplesInDocumentation()
    {
        RE2 re = RE2.Compile("(?i:co(.)a)");
        AssertEquals(new List<string> { "Copa", "coba" }, re.FindAll("Copacobana", 10));
        var x = re.FindAllSubmatch("Copacobana", 100);
        AssertEquals(new List<string> { "Copa", "p" }, new List<string>(x[0]));
        AssertEquals(new List<string> { "coba", "b" }, new List<string>(x[1]));
    }

    [TestMethod]
    public void TestRE2Search()
    {
        var file = "re2-search.txt";
        using var reader = new StreamReader(file, System.Text.Encoding.UTF8);

        TestRE2(file,reader);
    }

    [TestMethod]
    public void TestLineEnd()
    {
        var full = ".*\n.*";

        var re = RE2.Compile(full);

        Assert.IsTrue(re.Match("a\nb"));
        Assert.IsTrue(re.Match("a"+Environment.NewLine+"b"));

        full = ".*\r.*";
        re = RE2.Compile(full);

        Assert.IsFalse(re.Match("a\nb"));
        Assert.IsTrue(re.Match("a" + Environment.NewLine + "b"));

    }
    [TestMethod]
    public void TestRE2Exhaustive()
    {
        var file = "re2-exhaustive.txt.gz";
        using var fs = new FileStream(file, FileMode.Open);
        using var gz = new GZipStream(fs, CompressionMode.Decompress, true);
        using var reader = new UNIXBufferedReader(gz, System.Text.Encoding.UTF8);

        TestRE2(file,reader); // takes about 30s
    }


    public void TestRE2(string file,StreamReader reader)
    {
        int lineno = 0;
        List<string> strings = new List<string>();
        int input = 0; // next index within strings to read
        bool inStrings = false;
        RE2 re = null, refull = null;
        int nfail = 0, ncase = 0;
        string? line;
        while ((line = reader.ReadLine()) != null)
        {
            lineno++;
            if (line=="")
            {
                Fail(string.Format("{0}:{1}: unexpected blank line", file, lineno));
            }

            char first = line[0];
            if (first == '#')
            {
                continue;
            }
            if ('A' <= first && first <= 'Z')
            {
                // Test name.
                Debug.WriteLine(line);
                continue;
            }
            else if (line.Equals("strings"))
            {
                if (input < strings.Count)
                {
                    Fail(
                        string.Format(
                            "{0}:{1}: _out of sync: have {2} strings left",
                            file,
                            lineno,
                            strings.Count - input));
                }
                strings.Clear();
                inStrings = true;
            }
            else if (line.Equals("regexps"))
            {
                inStrings = false;
            }
            else if (first == '"')
            {
                string q ="";
                var allow_multiline = false;
#if false
                if (line.Length<2||line[line.Length-1]!='\"')
                {

                    //skip one line
                    var following_line = reader.ReadLine();
                    if (following_line == null) break;
                    lineno++;
                    line = line + "\n" + following_line;
                    allow_multiline = true;
                }
#endif       
                try
                {
                    q = Strconv.Unquote(line,allow_multiline);
                }
                catch (Exception e)
                {
                    // Fatal because we'll get _out of sync.
                    Fail(string.Format("{0}:{1}: unquote {2}: {3}", file, lineno, line, e.Message));
                    q = null; // unreachable
                }
                if (inStrings)
                {
                    strings.Add(q);
                    continue;
                }
                // Is a regexp.
                re = refull = null;
                try
                {
                    re = RE2.Compile(q);
                }
                catch (Exception e)
                { // (handle compiler panic too)
                    if (e.Message.Equals("error parsing regexp: invalid escape sequence: `\\C`"))
                    {
                        // We don't and likely never will support \C; keep going.
                        continue;
                    }
                    Debug.WriteLine("{0}:{1}: compile {2}: {3}\n", file, lineno, q, e.Message);
                    if (++nfail >= 100)
                    {
                        Fail("stopping after " + nfail + " errors");
                    }
                    continue;
                }
                string full = "\\A(?:" + q + ")\\z";
                try
                {
                    refull = RE2.Compile(full);
                }
                catch (Exception e)
                { // (handle compiler panic too)
                  // Fatal because q worked, so this should always work.
                    Fail(string.Format("{0}:{1}: compile full {2}: {3}", file, lineno, full, e.Message));
                }
                input = 0;
            }
            else if (first == '-' || ('0' <= first && first <= '9'))
            {
                // A sequence of match results.
                ncase++;
                if (re == null)
                {
                    // Failed to compile: skip results.
                    continue;
                }
                if (input >= strings.Count)
                {
                    Fail(string.Format("{0}:{1}: _out of sync: no input remaining", file, lineno));
                }
                string text = strings[(input++)];
                bool multibyte = !IsSingleBytes(text);
                if (multibyte && re.ToString().Contains("\\B"))
                {
                    // C++ RE2's \B considers every position _in the input, which
                    // is a stream of bytes, so it sees 'not word boundary' _in the
                    // middle of a rune.  But this package only considers whole
                    // runes, so it disagrees.  Skip those cases.
                    continue;
                }
                List<string> res = line.Split(';').ToList();// Splitter.on(';').splitToList(line);
                if (res.Count != 4)
                {
                    Fail(string.Format("{0}:{1}: have {2} test results, want {3}", file, lineno, res.Count, 4));
                }
                for (int i = 0; i < 4; ++i)
                {
                    bool partial = (i & 1) != 0, longest = (i & 2) != 0;
                    RE2 regexp = partial ? re : refull;

                    regexp.longest = longest;
                    int[] have = regexp.FindSubmatchIndex(text); // UTF-16 indices
                    if (multibyte && have != null)
                    {
                        // The testdata uses UTF-8 indices, but we're using the UTF-16 API.
                        // Perhaps we should use the UTF-8 RE2 API?
                        have = Utf16IndicesToUtf8(have, text);
                    }
                    int[] want = ParseResult(file, lineno, res[i]); // UTF-8 indices
                    if (want!=null && have!=null && !Enumerable.SequenceEqual(want, have))
                    {
                        Debug.WriteLine(
                            "{0}:{1}: {2}[partial={3},longest={4}].findSubmatchIndex({5}) = " + "{6}, want {7}\n",
                            file,
                            lineno,
                            re,
                            partial,
                            longest,
                            text,
                            (have),
                            (want));
                        if (++nfail >= 100)
                        {
                            Fail("stopping after " + nfail + " errors");
                        }
                        continue;
                    }

                    regexp.longest = longest;
                    bool b = regexp.Match(text);
                    if (b != (want != null))
                    {
                        Debug.WriteLine(
                            "{0}:{1}: {2}[partial={3},longest={4}].match({5}) = " + "{6}, want {7}\n",
                            file,
                            lineno,
                            re,
                            partial,
                            longest,
                            text,
                            b,
                            !b);
                        if (++nfail >= 200)
                        {
                            Fail("stopping after " + nfail + " errors");
                        }
                        continue;
                    }
                }
            }
            else
            {
                Fail(string.Format("{0}:{1}: _out of sync: {2}\n", file, lineno, line));
            }
        }
        if (input < strings.Count)
        {
            Fail(
                string.Format(
                    "{0}:{1}: _out of sync: have {2} strings left at EOF",
                    file,
                    lineno,
                    strings.Count - input));
        }
        if (nfail > 0)
        {
            Fail(string.Format("Of {0} cases tested, {1} failed", ncase, nfail));
        }
        else
        {
            Debug.WriteLine("{0} cases tested\n", ncase);
        }
    }

    // Returns true iff there are no runes with multibyte UTF-8 encodings _in s.
    private static bool IsSingleBytes(string s)
    {
        for (int i = 0, len = s.Length; i < len; ++i)
        {
            if (s[i] >= 0x80)
            {
                return false;
            }
        }
        return true;
    }

    // Convert |idx16|, which are Java (UTF-16) string indices, into the
    // corresponding indices _in the UTF-8 encoding of |text|.
    private static int[] Utf16IndicesToUtf8(int[] idx16, string text)
    {
        try
        {
            int[] idx8 = new int[idx16.Length];
            for (int i = 0; i < idx16.Length; ++i)
            {
                idx8[i] = System.Text.Encoding.UTF8.GetBytes( 
                    text.Substring(0, idx16[i]-0)).Length;
            }
            return idx8;
        }
        catch (Exception e)
        {
            throw (e);
        }
    }

    private static int[] ParseResult(string file, int lineno, string res)
    {
        // A single - indicates no match.
        if (res.Equals("-"))
        {
            return null;
        }
        // Otherwise, a space-separated list of pairs.
        int n = 1;
        // TODO(adonovan): is this safe or must we decode UTF-16?
        int len = res.Length;
        for (int j = 0; j < len; j++)
        {
            if (res[j] == ' ')
            {
                n++;
            }
        }
        int[] _out = new int[2 * n];
        int i = 0;
        n = 0;
        for (int j = 0; j <= len; j++)
        {
            if (j == len || res[j] == ' ')
            {
                // Process a single pair.  - means no submatch.
                string pair = res.Substring(i, j-i);
                if (pair.Equals("-"))
                {
                    _out[n++] = -1;
                    _out[n++] = -1;
                }
                else
                {
                    int k = pair.IndexOf('-');
                    if (k < 0)
                    {
                        Fail(string.Format("{0}:{1}: invalid pair {2}", file, lineno, pair));
                    }
                    int lo = -1, hi = -2;
                    int.TryParse(pair.Substring(0, k-0), out lo);
                    int.TryParse(pair.Substring(k + 1), out hi);
                    if (lo > hi)
                    {
                        Fail(string.Format("{0}:{1}: invalid pair {2}", file, lineno, pair));
                    }
                    _out[n++] = lo;
                    _out[n++] = hi;
                }
                i = j + 1;
            }
        }
        return _out;
    }

    // The testFowler* methods run this package's regexp API against the
    // POSIX regular expression tests collected by Glenn Fowler at
    // http://www2.research.att.com/~gsf/testregex/.

    [TestMethod]
    public void TestFowlerBasic()
    {
        TestFowler("basic.dat");
    }

    [TestMethod]
    public void TestFowlerNullSubexpr()
    {
        TestFowler("nullsubexpr.dat");
    }

    [TestMethod]
    public void TestFowlerRepetition()
    {
        TestFowler("repetition.dat");
    }

    private static readonly RE2 NOTAB = RE2.CompilePOSIX("[^\t]+");

    private void TestFowler(string file)
    {

        // TODO(adonovan): call _in.close() on all paths.
        using var reader = new StreamReader(file,System.Text.Encoding.UTF8);
        int lineno = 0;
        int nerr = 0;
        string? line;
        string lastRegexp = "";
        while ((line = reader.ReadLine()) != null)
        {
            lineno++;
            // if (line.isEmpty()) {
            //   Fail(string.format("%s:%d: unexpected blank line", file, lineno));
            // }

            // http://www2.research.att.com/~gsf/man/man1/testregex.html
            //
            // INPUT FORMAT
            //   Input lines may be blank, a comment beginning with #, or a test
            //   specification. A specification is five fields separated by one
            //   or more tabs. NULL denotes the empty string and NULL denotes the
            //   0 pointer.
            if (line=="" || line[0] == '#')
            {
                continue;
            }
            List<string> field = NOTAB.FindAll(line, -1);
            for (int i = 0; i < field.Count; ++i)
            {
                if (field[i].Equals("NULL"))
                {
                    field[i] = "";
                }
                if (field[i].Equals("NIL"))
                {
                    Debug.WriteLine("{0}:{1}: skip: {2}\n", file, lineno, line);
                    continue;
                }
            }
            if (field.Count==0)
            {
                continue;
            }

            //   Field 1: the regex(3) flags to apply, one character per
            //   REG_feature flag. The test is skipped if REG_feature is not
            //   supported by the implementation. If the first character is
            //   not [BEASKLP] then the specification is a global control
            //   line. One or more of [BEASKLP] may be specified; the test
            //   will be repeated for each mode.
            //
            //     B        basic                   BRE     (grep, ed, sed)
            //     E        REG_EXTENDED            ERE     (egrep)
            //     A        REG_AUGMENTED           ARE     (egrep with negation)
            //     S        REG_SHELL               SRE     (sh glob)
            //     K        REG_SHELL|REG_AUGMENTED KRE     (ksh glob)
            //     L        REG_LITERAL             LRE     (fgrep)
            //
            //     a        REG_LEFT|REG_RIGHT      implicit ^...$
            //     b        REG_NOTBOL              lhs does not match ^
            //     c        REG_COMMENT             ignore space and #...\n
            //     d        REG_SHELL_DOT           explicit leading . match
            //     e        REG_NOTEOL              rhs does not match $
            //     f        REG_MULTIPLE            multiple \n separated patterns
            //     g        FNM_LEADING_DIR         testfnmatch only -- match until /
            //     h        REG_MULTIREF            multiple digit backref
            //     i        REG_ICASE               ignore case
            //     j        REG_SPAN                . matches \n
            //     k        REG_ESCAPE              \ to ecape [...] delimiter
            //     l        REG_LEFT                implicit ^...
            //     m        REG_MINIMAL             minimal match
            //     n        REG_NEWLINE             explicit \n match
            //     o        REG_ENCLOSED            (|&) magic inside [@|&](...)
            //     p        REG_SHELL_PATH          explicit / match
            //     q        REG_DELIMITED           delimited pattern
            //     r        REG_RIGHT               implicit ...$
            //     s        REG_SHELL_ESCAPED       \ not special
            //     t        REG_MUSTDELIM           all delimiters must be specified
            //     u        standard unspecified behavior -- errors not counted
            //     v        REG_CLASS_ESCAPE        \ special inside [...]
            //     w        REG_NOSUB               no subexpression match array
            //     x        REG_LENIENT             let some errors slide
            //     y        REG_LEFT                regexec() implicit ^...
            //     z        REG_NULL                NULL subexpressions ok
            //     $                                expand C \c escapes _in fields
            //                                      2 and 3
            //     /                                field 2 is a regsubcomp() expr
            //     =                                field 3 is a regdecomp() expr
            //
            //   Field 1 control lines:
            //
            //     C                set LC_COLLATE and LC_CTYPE to locale _in field 2
            //
            //     ?test ...        output field 5 if passed and != EXPECTED,
            //                      silent otherwise
            //     &test ...        output field 5 if current and previous passed
            //     |test ...        output field 5 if current passed and
            //                      previous failed
            //     ; ...            output field 2 if previous failed
            //     {test ...        skip if failed until }
            //     }                end of skip
            //
            //     : comment        comment copied as output NOTE
            //     :comment:test    :comment: ignored
            //     N[OTE] comment   comment copied as output NOTE
            //     T[EST] comment   comment
            //
            //     number           use number for nmatch (20 by default)
            string flag = field[0];
            switch (flag[0])
            {
                case '?':
                case '&':
                case '|':
                case ';':
                case '{':
                case '}':
                    // Ignore all the control operators.
                    // Just run everything.
                    flag = flag.Substring(1);
                    if (flag=="")
                    {
                        continue;
                    }
                    break;
                case ':':
                    {
                        int i = flag.IndexOf(':', 1);
                        if (i < 0)
                        {
                            Debug.WriteLine("skip: {0}\n", line);
                            continue;
                        }
                        flag = flag.Substring(1 + i + 1);
                        break;
                    }
                case 'C':
                case 'N':
                case 'T':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    Debug.WriteLine("skip: {0}\n", line);
                    continue;
            }

            // Can check field count now that we've handled the myriad comment
            // formats.
            if (field.Count < 4)
            {
                Debug.WriteLine("{0}:{1}: too few fields: {2}\n", file, lineno, line);
                nerr++;
                continue;
            }

            // Expand C escapes (a.k.a. Go escapes).
            if (flag.IndexOf('$') >= 0)
            {
                string f = "\"" + field[1] + "\"";
                try
                {
                    field[1]=Strconv.Unquote(f);
                }
                catch (Exception e)
                {
                    Debug.WriteLine("{0}:{1}: cannot unquote {2}\n", file, lineno, f);
                    nerr++;
                }
                f = "\"" + field[2] + "\"";
                try
                {
                    field[2]=(Strconv.Unquote(f));
                }
                catch (Exception e)
                {
                    Debug.WriteLine("{0}:{1}: cannot unquote {2}\n", file, lineno, f);
                    nerr++;
                }
            }

            //   Field 2: the regular expression pattern; SAME uses the pattern from
            //     the previous specification.
            //
            if (field[1].Equals("SAME"))
            {
                field[1]= lastRegexp;
            }
            lastRegexp = field[1];

            //   Field 3: the string to match.
            string text = field[2];

            //   Field 4: the test outcome...
            bool[] shouldCompileMatch = { false, false }; // _in/_out param to parser
            List<int> pos;
            try
            {
                pos = ParseFowlerResult(field[3], shouldCompileMatch);
            }
            catch (Exception e)
            {
                Debug.WriteLine("{0}:{1}: cannot parse result {2}\n", file, lineno, field[3]);
                nerr++;
                continue;
            }

            //   Field 5: optional comment appended to the report.

            // Run test once for each specified capital letter mode that we support.
            foreach (char c in flag.ToCharArray())
            {
                string pattern = field[1];//.get(1);
                int flags = RE2.POSIX | RE2.CLASS_NL;
                switch (c)
                {
                    default:
                        continue;
                    case 'E':
                        // extended regexp (what we support)
                        break;
                    case 'L':
                        // literal
                        pattern = RE2.QuoteMeta(pattern);
                        break;
                }

                if (flag.IndexOf('i') >= 0)
                {
                    flags |= RE2.FOLD_CASE;
                }

                RE2 re = null;
                try
                {
                    re = RE2.CompileImpl(pattern, flags, true);
                }
                catch (PatternSyntaxException e)
                {
                    if (shouldCompileMatch[0])
                    {
                        Debug.WriteLine("{0}:{1}: {2} did not compile\n", file, lineno, pattern);
                        nerr++;
                    }
                    continue;
                }
                if (!shouldCompileMatch[0])
                {
                    Debug.WriteLine("{0}:{1}: {2} should not compile\n", file, lineno, pattern);
                    nerr++;
                    continue;
                }
                bool match = re.Match(text);
                if (match != shouldCompileMatch[1])
                {
                    Debug.WriteLine(
                        "{0}:{1}: {2}.match({3}) = {4}, want {5}\n", file, lineno, pattern, text, match, !match);
                    nerr++;
                    continue;
                }
                int[] haveArray = re.FindSubmatchIndex(text);
                if (haveArray == null)
                {
                    haveArray = Utils.EMPTY_INTS; // to make .Length and printing safe
                }
                if ((haveArray.Length > 0) != match)
                {
                    Debug.WriteLine(
                        "{0}:{1}: {2}.match({3}) = {4}, " + "but {5}.findSubmatchIndex({6}) = {7}\n",
                        file,
                        lineno,
                        pattern,
                        text,
                        match,
                        pattern,
                        text,
                        (haveArray));
                    nerr++;
                    continue;
                }
                // Convert int[] to List<int> and truncate to pos.Length.
                List<int> have = new ();
                for (int i = 0; i < pos.Count; ++i)
                {
                    have.Add(haveArray[i]);
                }
                if (!Enumerable.SequenceEqual(have, pos))//; have.Equals(pos))
                {
                    Debug.WriteLine(
                        "{0}:{1}: {2}.findSubmatchIndex({3}) = {4}, want {5}\n",
                        file,
                        lineno,
                        pattern,
                        text,
                        have,
                        pos);
                    nerr++;
                    continue;
                }
            }
        }
        if (nerr > 0)
        {
            Fail("There were " + nerr + " errors");
        }
    }

    private static void Fail(string v)
    {
        Assert.Fail(v);
    }

    private static List<int> ParseFowlerResult(string s, bool[] shouldCompileMatch)
    {
        string olds = s;
        //   Field 4: the test outcome. This is either one of the posix error
        //     codes (with REG_ omitted) or the match array, a list of (m,n)
        //     entries with m and n being first and last+1 positions _in the
        //     field 3 string, or NULL if REG_NOSUB is _in effect and success
        //     is expected. BADPAT is acceptable _in place of any regcomp(3)
        //     error code. The match[] array is initialized to (-2,-2) before
        //     each test. All array elements from 0 to nmatch-1 must be specified
        //     _in the outcome. Unspecified endpoints (offset -1) are denoted by ?.
        //     Unset endpoints (offset -2) are denoted by X. {x}(o:n) denotes a
        //     matched (?{...}) expression, where x is the text enclosed by {...},
        //     o is the expression ordinal counting from 1, and n is the Length of
        //     the unmatched portion of the subject string. If x starts with a
        //     number then that is the return value of re_execf(), otherwise 0 is
        //     returned.
        if (s==null)
        {
            // Match with no position information.
            shouldCompileMatch[0] = true;
            shouldCompileMatch[1] = true;
            return new();
        }
        else if (s.Equals("NOMATCH"))
        {
            // Match failure.
            shouldCompileMatch[0] = true;
            shouldCompileMatch[1] = false;
            return new();
        }
        else if ('A' <= s[0] && s[0] <= 'Z')
        {
            // All the other error codes are compile errors.
            shouldCompileMatch[0] = false;
            return new();
        }
        shouldCompileMatch[0] = true;
        shouldCompileMatch[1] = true;

        List<int> result = new ();
        while (!string.IsNullOrEmpty(s))
        {
            char end = ')';
            if ((result.Count % 2) == 0)
            {
                if (s[0] != '(')
                {
                    throw new Exception("parse error: missing '('");
                }
                s = s.Substring(1);
                end = ',';
            }
            int i = s.IndexOf(end);
            if (i <= 0)
            { // [sic]
                throw new Exception("parse error: missing '" + end + "'");
            }
            string num = s.Substring(0, i-0);
            if (!num.Equals("?"))
            {
                result.Add(int.TryParse(num,out var v)?v:-1); // (may throw)
            }
            else
            {
                result.Add(-1);
            }
            s = s.Substring(i + 1);
        }
        if ((result.Count % 2) != 0)
        {
            throw new Exception("parse error: odd number of fields");
        }
        return result;
    }
}